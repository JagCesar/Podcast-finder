//
//  MessagesViewController.swift
//  MessagesExtension
//
//  Created by Cesar Pinto Castillo on 2016-08-31.
//  Copyright Â© 2016 JagCesar. All rights reserved.
//

import UIKit
import Messages
import Alamofire

protocol PodcastSelectedDelegate: class {
    func podcastSelected(indexPath: IndexPath)
}

class MessagesViewController: MSMessagesAppViewController, PodcastSelectedDelegate, UISearchBarDelegate {

    @IBOutlet var collectionView: UICollectionView! {
        didSet {
            collectionView.dataSource = collectionViewDataSource
            collectionView.delegate = collectionViewDelegate
        }
    }
    @IBOutlet var searchBar: UISearchBar!
    @IBOutlet var onboardingTitle: UILabel!
    @IBOutlet var onboardingSubtitle: UILabel!
    @IBOutlet var activityIndicator: UIActivityIndicatorView!
    private let collectionViewDataSource: CollectionViewDataSource = CollectionViewDataSource()
    private let collectionViewDelegate: CollectionViewDelegate = CollectionViewDelegate()

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.

        collectionViewDelegate.podcastSelectedDelegate = self
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    // MARK: - Conversation Handling

    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.

        // Use this method to configure the extension and restore previously stored state.
    }

    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.

        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }

    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.

        // Use this method to trigger UI updates in response to the message.
    }

    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }

    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.

        // Use this to clean up state related to the deleted message.
    }

    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.

        // Use this method to prepare for the change in presentation style.
    }

    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.

        // Use this method to finalize any behaviors associated with the change in presentation style.
        switch presentationStyle {
        case .expanded:
            searchBar.becomeFirstResponder()
        case .compact:
            fallthrough
        default:
            false
        }
    }

    // MARK: - UISearchBarDelegate

    func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
        if presentationStyle == .expanded {
            return true
        } else {
            requestPresentationStyle(.expanded)
            return false
        }
    }

    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
        guard let needle = searchBar.text else { return }

        collectionViewDataSource.items = []
        collectionView.reloadData()

        activityIndicator.startAnimating()

        onboardingTitle.isHidden = true
        onboardingSubtitle.isHidden = true

        searchBar.resignFirstResponder()
        ItunesSearch.searchPodcast(term: needle) { [weak self] (results, error) in
            self?.activityIndicator.stopAnimating()
            self?.collectionViewDataSource.items = results ?? []
            self?.collectionView.reloadData()
        }
    }

    // MARK: - PodcastSelectedDelegate

    func podcastSelected(indexPath: IndexPath) {
        let message = MSMessage()
        let selectedPodcast = collectionViewDataSource.items[indexPath.item]

        Alamofire.request(URLRequest(url: selectedPodcast.artworkUrl600))
            .responseImage(completionHandler: { [weak self] response in
                self?.activeConversation?.insertText("Check out this awesome Podcast named " + selectedPodcast.collectionName + "\n" + selectedPodcast.itunesUrl.absoluteString, completionHandler: nil)
                self?.requestPresentationStyle(.compact)
            })
    }
}

class CollectionViewDataSource: NSObject, UICollectionViewDataSource {
    var items: [PodcastSearchResult] = []
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return items.count
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
        if let cell = cell as? PodcastSearchResultCollectionViewCell {
            cell.podcastSearchResult = items[indexPath.row]
        }
        return cell
    }
}

class CollectionViewDelegate: NSObject, UICollectionViewDelegate {
    weak var podcastSelectedDelegate: PodcastSelectedDelegate?
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        podcastSelectedDelegate?.podcastSelected(indexPath: indexPath)
    }
}
